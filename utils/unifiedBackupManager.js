const mongoBackup = require('./mongoBackupManager');
const robustBackup = require('./robustBackupManager');
const dataValidator = require('./dataValidator');

class UnifiedBackupManager {
    constructor() {
        this.mongoAvailable = false;
        this.initialized = false;
        this.backupStrategy = 'robust'; // 'mongo', 'robust', 'hybrid'
        
        this.init();
    }

    async init() {
        try {
            console.log('üîÑ Initialisation du syst√®me de sauvegarde unifi√©...');
            
            // V√©rifier la disponibilit√© de MongoDB
            this.mongoAvailable = await this.checkMongoAvailability();
            
            // D√©terminer la strat√©gie de sauvegarde
            if (this.mongoAvailable) {
                this.backupStrategy = 'hybrid'; // MongoDB + Backup local
                console.log('‚úÖ Strat√©gie: Hybride (MongoDB + Sauvegarde locale)');
            } else {
                this.backupStrategy = 'robust'; // Sauvegarde locale uniquement
                console.log('üìÅ Strat√©gie: Sauvegarde locale robuste uniquement');
            }
            
            // V√©rifier l'int√©grit√© des donn√©es au d√©marrage
            await this.performStartupCheck();
            
            this.initialized = true;
            console.log('‚úÖ Syst√®me de sauvegarde unifi√© initialis√©');
            
        } catch (error) {
            console.error('‚ùå Erreur initialisation syst√®me de sauvegarde:', error);
            this.backupStrategy = 'robust'; // Fallback vers sauvegarde locale
            this.initialized = true;
        }
    }

    async checkMongoAvailability() {
        try {
            // V√©rifier les variables d'environnement
            const hasCredentials = process.env.MONGODB_USERNAME && 
                                 process.env.MONGODB_PASSWORD && 
                                 process.env.MONGODB_CLUSTER_URL;
            
            if (!hasCredentials) {
                console.log('‚ö†Ô∏è Variables MongoDB manquantes - utilisation locale uniquement');
                return false;
            }
            
            // Tenter une connexion
            const connected = await mongoBackup.connect();
            if (connected) {
                console.log('‚úÖ MongoDB disponible');
                return true;
            } else {
                console.log('‚ùå MongoDB indisponible');
                return false;
            }
            
        } catch (error) {
            console.log('‚ùå Erreur v√©rification MongoDB:', error.message);
            return false;
        }
    }

    async performStartupCheck() {
        try {
            console.log('üîç V√©rification int√©grit√© au d√©marrage...');
            
            const healthReport = await dataValidator.generateHealthReport();
            
            if (healthReport.status === 'ISSUES_DETECTED') {
                console.log('‚ö†Ô∏è Probl√®mes d√©tect√©s dans les donn√©es');
                
                // Tenter une r√©paration automatique
                const repairResult = await dataValidator.autoRepair();
                if (repairResult.success) {
                    console.log(`‚úÖ ${repairResult.repaired} fichiers r√©par√©s automatiquement`);
                }
                
                // Si des probl√®mes persistent, tenter une restauration
                if (healthReport.summary.invalid > 0 || healthReport.summary.missing > 0) {
                    await this.attemptDataRecovery();
                }
            } else {
                console.log('‚úÖ Donn√©es int√®gres au d√©marrage');
            }
            
        } catch (error) {
            console.error('‚ùå Erreur v√©rification d√©marrage:', error);
        }
    }

    async attemptDataRecovery() {
        try {
            console.log('üîÑ Tentative de r√©cup√©ration des donn√©es...');
            
            // 1. Essayer de restaurer depuis MongoDB si disponible
            if (this.mongoAvailable) {
                console.log('üì• Tentative restauration MongoDB...');
                const mongoRestore = await mongoBackup.restoreFromMongo();
                if (mongoRestore.success) {
                    console.log('‚úÖ Donn√©es restaur√©es depuis MongoDB');
                    return true;
                }
            }
            
            // 2. Essayer de restaurer depuis la sauvegarde locale la plus r√©cente
            console.log('üì• Tentative restauration sauvegarde locale...');
            const backups = await robustBackup.listBackups();
            if (backups.length > 0) {
                const restoreResult = await robustBackup.restoreFromBackup();
                if (restoreResult.success) {
                    console.log('‚úÖ Donn√©es restaur√©es depuis sauvegarde locale');
                    return true;
                }
            }
            
            // 3. Cr√©er des donn√©es par d√©faut en dernier recours
            console.log('üîß Cr√©ation de donn√©es par d√©faut...');
            const repairResult = await dataValidator.autoRepair();
            if (repairResult.success) {
                console.log('‚úÖ Donn√©es par d√©faut cr√©√©es');
                return true;
            }
            
            return false;
            
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration donn√©es:', error);
            return false;
        }
    }

    // Sauvegarde selon la strat√©gie d√©finie
    async performBackup(force = false) {
        try {
            if (!this.initialized && !force) {
                console.log('‚ö†Ô∏è Syst√®me non initialis√© - sauvegarde ignor√©e');
                return { success: false, reason: 'System not initialized' };
            }

            console.log(`üíæ Sauvegarde ${this.backupStrategy}...`);
            
            const results = {
                strategy: this.backupStrategy,
                mongo: null,
                local: null,
                success: false
            };

            switch (this.backupStrategy) {
                case 'mongo':
                    results.mongo = await mongoBackup.backupToMongo();
                    results.success = results.mongo?.success || false;
                    break;
                    
                case 'robust':
                    results.local = await robustBackup.createFullBackup();
                    results.success = results.local?.success || false;
                    break;
                    
                case 'hybrid':
                    // Sauvegarder sur les deux syst√®mes
                    results.local = await robustBackup.createFullBackup();
                    results.mongo = await mongoBackup.backupToMongo();
                    results.success = results.local?.success || results.mongo?.success || false;
                    
                    if (results.local?.success && results.mongo?.success) {
                        console.log('‚úÖ Sauvegarde hybride compl√®te r√©ussie');
                    } else if (results.local?.success) {
                        console.log('‚úÖ Sauvegarde locale r√©ussie (MongoDB √©chou√©)');
                    } else if (results.mongo?.success) {
                        console.log('‚úÖ Sauvegarde MongoDB r√©ussie (locale √©chou√©e)');
                    }
                    break;
            }

            if (results.success) {
                console.log(`‚úÖ Sauvegarde ${this.backupStrategy} termin√©e`);
            } else {
                console.log(`‚ùå √âchec sauvegarde ${this.backupStrategy}`);
            }

            return results;
            
        } catch (error) {
            console.error('‚ùå Erreur sauvegarde unifi√©e:', error);
            return { success: false, error: error.message };
        }
    }

    // Restauration intelligente avec priorit√©s
    async performRestore(source = 'auto') {
        try {
            console.log(`üì• Restauration depuis source: ${source}`);
            
            if (source === 'auto') {
                // Essayer MongoDB en premier si disponible
                if (this.mongoAvailable) {
                    const mongoResult = await mongoBackup.restoreFromMongo();
                    if (mongoResult.success) {
                        console.log('‚úÖ Restauration MongoDB r√©ussie');
                        return mongoResult;
                    }
                }
                
                // Fallback vers sauvegarde locale
                const localResult = await robustBackup.restoreFromBackup();
                if (localResult.success) {
                    console.log('‚úÖ Restauration locale r√©ussie');
                    return localResult;
                }
                
                throw new Error('Aucune source de restauration disponible');
                
            } else if (source === 'mongo') {
                return await mongoBackup.restoreFromMongo();
            } else if (source === 'local') {
                return await robustBackup.restoreFromBackup();
            }
            
        } catch (error) {
            console.error('‚ùå Erreur restauration:', error);
            return { success: false, error: error.message };
        }
    }

    // Sauvegarde d'urgence prioritaire
    async emergencyBackup() {
        try {
            console.log('üö® SAUVEGARDE D\'URGENCE D√âCLENCH√âE');
            
            const results = {
                emergency: null,
                mongo: null,
                success: false
            };

            // 1. Sauvegarde d'urgence locale (rapide)
            results.emergency = await robustBackup.emergencyBackup();
            
            // 2. Tentative MongoDB si disponible (peut √™tre lent)
            if (this.mongoAvailable) {
                try {
                    results.mongo = await mongoBackup.backupToMongo();
                } catch (error) {
                    console.log('‚ö†Ô∏è Sauvegarde MongoDB d\'urgence √©chou√©e:', error.message);
                }
            }
            
            results.success = results.emergency?.success || results.mongo?.success || false;
            
            if (results.success) {
                console.log('‚úÖ Sauvegarde d\'urgence r√©ussie');
            } else {
                console.log('‚ùå √âchec sauvegarde d\'urgence');
            }
            
            return results;
            
        } catch (error) {
            console.error('‚ùå Erreur sauvegarde d\'urgence:', error);
            return { success: false, error: error.message };
        }
    }

    // Rapport de statut complet
    async getSystemStatus() {
        try {
            const status = {
                timestamp: new Date().toISOString(),
                initialized: this.initialized,
                strategy: this.backupStrategy,
                mongo: {
                    available: this.mongoAvailable,
                    connected: this.mongoAvailable ? await mongoBackup.connect() : false
                },
                data: await dataValidator.generateHealthReport(),
                backups: {
                    local: await robustBackup.listBackups()
                }
            };
            
            // V√©rifier les sauvegardes MongoDB si disponible
            if (this.mongoAvailable) {
                try {
                    status.mongo.integrity = await mongoBackup.verifyBackupIntegrity();
                } catch (error) {
                    status.mongo.error = error.message;
                }
            }
            
            return status;
            
        } catch (error) {
            return {
                timestamp: new Date().toISOString(),
                error: error.message,
                status: 'ERROR'
            };
        }
    }

    // D√©marrer la sauvegarde automatique
    startAutoBackup(intervalMinutes = 30) {
        console.log(`üïê Syst√®me de sauvegarde automatique unifi√© d√©marr√© (${intervalMinutes} min)`);
        
        // Sauvegarde imm√©diate
        setTimeout(() => this.performBackup(), 10000);
        
        // Sauvegarde p√©riodique
        setInterval(async () => {
            await this.performBackup();
        }, intervalMinutes * 60 * 1000);
        
        // V√©rification quotidienne
        setInterval(async () => {
            const status = await this.getSystemStatus();
            if (status.data?.status === 'ISSUES_DETECTED') {
                console.log('‚ö†Ô∏è Probl√®mes d√©tect√©s - sauvegarde d\'urgence');
                await this.emergencyBackup();
            }
        }, 24 * 60 * 60 * 1000);
        
        // Configuration des sauvegardes d'urgence
        this.setupEmergencyHandlers();
    }

    setupEmergencyHandlers() {
        const emergencyHandler = async () => {
            console.log('üö® Signal d\'arr√™t d√©tect√© - sauvegarde d\'urgence...');
            await this.emergencyBackup();
            process.exit(0);
        };

        process.on('SIGTERM', emergencyHandler);
        process.on('SIGINT', emergencyHandler);
        process.on('beforeExit', emergencyHandler);
    }
}

module.exports = new UnifiedBackupManager();