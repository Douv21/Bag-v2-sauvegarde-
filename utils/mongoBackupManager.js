// Utilisation optionnelle de MongoDB - fallback si module indisponible
let MongoClient;
try {
    MongoClient = require('mongodb').MongoClient;
} catch (error) {
    console.log('üì¶ Module MongoDB non disponible - mode fichier local uniquement');
    MongoClient = null;
}
const fs = require('fs').promises;
const path = require('path');

class MongoBackupManager {
    constructor() {
        this.client = null;
        this.db = null;
        this.connected = false;
        
        // Construction de la cha√Æne de connexion avec les nouvelles variables
        const username = process.env.MONGODB_USERNAME || 'douvdouv21';
        const password = process.env.MONGODB_PASSWORD;
        let clusterUrl = process.env.MONGODB_CLUSTER_URL || 'cluster0.5ujrblq.mongodb.net';
        
        // Nettoyer l'URL si elle contient d√©j√† le format complet
        if (clusterUrl.includes('mongodb+srv://')) {
            // Extraire juste le nom du cluster depuis l'URL compl√®te
            const match = clusterUrl.match(/@([^\/\?]+)/);
            if (match) {
                clusterUrl = match[1];
            }
        }
        
        this.connectionString = password ? 
            `mongodb+srv://${encodeURIComponent(username)}:${encodeURIComponent(password)}@${clusterUrl}/bagbot?retryWrites=true&w=majority` : 
            null;
        
        // Debug de connexion
        if (!password) {
            console.log('üîë MONGODB_PASSWORD non configur√© - sauvegarde locale uniquement');
        } else if (!username) {
            console.log('üîë MONGODB_USERNAME non configur√© - sauvegarde locale uniquement');
        } else if (!clusterUrl) {
            console.log('üîë MONGODB_CLUSTER_URL non configur√© - sauvegarde locale uniquement');
        } else {
            console.log(`üîë MongoDB configur√©: ${username}@${clusterUrl} - MongoDB disponible`);
            console.log(`üì° String de connexion: mongodb+srv://${username}:***@${clusterUrl}/bagbot`);
        }
        
        this.collections = {
            users: 'users',
            economy: 'economy', 
            confessions: 'confessions',
            counting: 'counting',
            autothread: 'autothread',
            shop: 'shop',
            karma: 'karma',
            configs: 'configs'
        };

        this.localFiles = {
            'economy.json': 'economy',
            'confessions.json': 'confessions', 
            'counting.json': 'counting',
            'autothread.json': 'autothread',
            'shop.json': 'shop',
            'karma_config.json': 'karma',
            'message_rewards.json': 'configs'
        };
    }

    async connect() {
        if (this.connected || !this.connectionString || !MongoClient) {
            return this.connected;
        }

        try {
            console.log('üîÑ Connexion MongoDB pour sauvegarde...');
            this.client = new MongoClient(this.connectionString, {
                serverSelectionTimeoutMS: 10000,
                connectTimeoutMS: 10000,
                maxPoolSize: 5
            });
            
            await this.client.connect();
            // Test de la connexion
            await this.client.db('admin').command({ ping: 1 });
            this.db = this.client.db('bagbot');
            this.connected = true;
            console.log('‚úÖ MongoDB connect√© pour syst√®me de sauvegarde');
            return true;
        } catch (error) {
            console.log(`‚ùå MongoDB indisponible (${error.message}) - mode fichier local uniquement`);
            this.connected = false;
            return false;
        }
    }

    async disconnect() {
        if (this.client && this.connected) {
            await this.client.close();
            this.connected = false;
            console.log('üîå MongoDB d√©connect√©');
        }
    }

    // SAUVEGARDE: Fichiers locaux ‚Üí MongoDB
    async backupToMongo() {
        if (!MongoClient) {
            console.log('‚ö†Ô∏è Sauvegarde MongoDB ignor√©e - module non disponible');
            return false;
        }
        
        if (!await this.connect()) {
            console.log('‚ö†Ô∏è Sauvegarde MongoDB ignor√©e - pas de connexion');
            return false;
        }

        try {
            console.log('üì§ D√©but sauvegarde automatique vers MongoDB...');
            let backupCount = 0;

            for (const [filename, collection] of Object.entries(this.localFiles)) {
                const filePath = path.join(__dirname, '..', 'data', filename);
                
                try {
                    const fileExists = await fs.access(filePath).then(() => true).catch(() => false);
                    if (!fileExists) {
                        console.log(`‚è≠Ô∏è ${filename} n'existe pas - ignor√©`);
                        continue;
                    }

                    const data = await fs.readFile(filePath, 'utf8');
                    const jsonData = JSON.parse(data);

                    // Sauvegarder avec timestamp
                    const backupDoc = {
                        filename: filename,
                        data: jsonData,
                        timestamp: new Date(),
                        deployment: process.env.RENDER_SERVICE_ID || 'local'
                    };

                    await this.db.collection(collection).replaceOne(
                        { filename: filename },
                        backupDoc,
                        { upsert: true }
                    );

                    backupCount++;
                    console.log(`‚úÖ ${filename} sauvegard√© dans collection ${collection}`);
                } catch (fileError) {
                    console.error(`‚ùå Erreur sauvegarde ${filename}:`, fileError.message);
                }
            }

            console.log(`üì§ Sauvegarde termin√©e: ${backupCount} fichiers sauvegard√©s`);
            return true;
        } catch (error) {
            console.error('‚ùå Erreur sauvegarde MongoDB:', error);
            return false;
        }
    }

    // RESTAURATION: MongoDB ‚Üí Fichiers locaux
    async restoreFromMongo() {
        if (!MongoClient) {
            console.log('‚ö†Ô∏è Restauration MongoDB ignor√©e - module non disponible');
            return false;
        }
        
        if (!await this.connect()) {
            console.log('‚ö†Ô∏è Restauration MongoDB ignor√©e - pas de connexion');
            return false;
        }

        try {
            console.log('üì• D√©but restauration depuis MongoDB...');
            let restoreCount = 0;

            // Cr√©er le dossier data s'il n'existe pas
            const dataDir = path.join(__dirname, '..', 'data');
            await fs.mkdir(dataDir, { recursive: true });

            for (const [filename, collection] of Object.entries(this.localFiles)) {
                try {
                    const backupDoc = await this.db.collection(collection)
                        .findOne({ filename: filename });

                    if (!backupDoc) {
                        console.log(`‚è≠Ô∏è Aucune sauvegarde trouv√©e pour ${filename}`);
                        continue;
                    }

                    const filePath = path.join(dataDir, filename);
                    await fs.writeFile(filePath, JSON.stringify(backupDoc.data, null, 2));

                    restoreCount++;
                    console.log(`‚úÖ ${filename} restaur√© depuis ${collection} (${backupDoc.timestamp})`);
                } catch (restoreError) {
                    console.error(`‚ùå Erreur restauration ${filename}:`, restoreError.message);
                }
            }

            console.log(`üì• Restauration termin√©e: ${restoreCount} fichiers restaur√©s`);
            return true;
        } catch (error) {
            console.error('‚ùå Erreur restauration MongoDB:', error);
            return false;
        }
    }

    // SAUVEGARDE AUTOMATIQUE P√âRIODIQUE
    startAutoBackup(intervalMinutes = 15) {
        console.log(`üïê Sauvegarde automatique d√©marr√©e (toutes les ${intervalMinutes} minutes)`);
        
        setInterval(async () => {
            await this.backupToMongo();
        }, intervalMinutes * 60 * 1000);

        // Sauvegarde imm√©diate au d√©marrage
        setTimeout(() => this.backupToMongo(), 5000);
    }

    // SAUVEGARDE D'URGENCE (avant arr√™t du processus)
    setupEmergencyBackup() {
        const emergencyBackup = async () => {
            console.log('üö® Sauvegarde d\'urgence en cours...');
            await this.backupToMongo();
            await this.disconnect();
        };

        process.on('SIGTERM', emergencyBackup);
        process.on('SIGINT', emergencyBackup);
        process.on('beforeExit', emergencyBackup);
    }

    // V√âRIFICATION INT√âGRIT√â DES DONN√âES
    async verifyBackupIntegrity() {
        if (!await this.connect()) return false;

        try {
            console.log('üîç V√©rification int√©grit√© des sauvegardes...');
            
            for (const [filename, collection] of Object.entries(this.localFiles)) {
                const backupDoc = await this.db.collection(collection)
                    .findOne({ filename: filename });
                
                if (backupDoc) {
                    const age = Date.now() - new Date(backupDoc.timestamp).getTime();
                    const ageHours = Math.floor(age / (1000 * 60 * 60));
                    
                    console.log(`üìä ${filename}: sauvegard√© il y a ${ageHours}h (${backupDoc.timestamp})`);
                } else {
                    console.log(`‚ö†Ô∏è ${filename}: aucune sauvegarde trouv√©e`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur v√©rification int√©grit√©:', error);
            return false;
        }
    }

    // NETTOYAGE DES ANCIENNES SAUVEGARDES
    async cleanOldBackups(keepDays = 7) {
        if (!await this.connect()) return false;

        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - keepDays);

            console.log(`üßπ Nettoyage sauvegardes ant√©rieures au ${cutoffDate.toISOString()}`);

            for (const collection of Object.values(this.collections)) {
                const result = await this.db.collection(collection)
                    .deleteMany({
                        timestamp: { $lt: cutoffDate },
                        filename: { $exists: true }
                    });

                if (result.deletedCount > 0) {
                    console.log(`üóëÔ∏è ${result.deletedCount} anciennes sauvegardes supprim√©es de ${collection}`);
                }
            }
            
            return true;
        } catch (error) {
            console.error('‚ùå Erreur nettoyage:', error);
            return false;
        }
    }
}

module.exports = new MongoBackupManager();