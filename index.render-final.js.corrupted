const { Client, Collection, GatewayIntentBits, Routes, REST, EmbedBuilder } = require('discord.js');
const fs = require('fs').promises;
const path = require('path');
const express = require('express');

class RenderSolutionBot {
    constructor() {
        this.initializeWebServer();
    }

    async initializeWebServer() {
        // 1. Serveur web d'abord (port 5000 pour Render.com)
        const app = express();
        const PORT = process.env.PORT || 5000;

        app.use(express.json());

        app.get('/', (req, res) => {
            res.json({
                status: 'running',
                version: '3.0',
                deployment: 'render.com',
                message: 'BAG v2 Discord Bot - Serveur Web Actif'
            });
        });

        app.get('/health', (req, res) => {
            res.json({ status: 'healthy', timestamp: new Date().toISOString() });
        });

        app.get('/commands-status', async (req, res) => {
            try {
                const commandsDir = path.join(__dirname, 'commands');
                const commandFiles = await fs.readdir(commandsDir);
                const commands = commandFiles.filter(file => file.endsWith('.js')).map(file => file.replace('.js', ''));
                
                res.json({
                    status: 'success',
                    commands: commands,
                    count: commands.length
                });
            } catch (error) {
                res.json({ status: 'error', message: error.message });
            }
        });

        // D√©marrer le serveur web AVANT Discord
        app.listen(PORT, '0.0.0.0', () => {
            console.log('üåê Serveur Web actif sur port', PORT);
            console.log('üìä Status: http://localhost:5000/commands-status');
            console.log('‚úÖ Port 5000 ouvert pour Render.com');
            
            // 2. Ensuite initialiser Discord
            setTimeout(() => this.initializeDiscord(), 1000);
        });
    }

    async initializeDiscord() {
        this.client = new Client({
            intents: [
                GatewayIntentBits.Guilds,
                GatewayIntentBits.GuildMessages,
                GatewayIntentBits.MessageContent,
                GatewayIntentBits.GuildMembers
            ]
        });

        this.commands = new Collection();
        await this.loadCommands();
        await this.setupEventHandlers();

        try {
            await this.client.login(process.env.DISCORD_TOKEN);
        } catch (error) {
            console.error('‚ùå Erreur connexion Discord:', error);
            process.exit(1);
        }
    }

    async loadCommands() {
        try {
            console.log('üìÇ Chargement de 25 commandes...');
            const commandsPath = path.join(__dirname, 'commands');
            const commandFiles = await fs.readdir(commandsPath);

            for (const file of commandFiles.filter(file => file.endsWith('.js'))) {
                try {
                    const filePath = path.join(commandsPath, file);
                    delete require.cache[require.resolve(filePath)];
                    const command = require(filePath);

                    if ('data' in command && 'execute' in command) {
                        this.commands.set(command.data.name, command);
                        console.log(`‚úÖ ${command.data.name}`);
                    } else {
                        console.log(`‚ùå ${file} manque data ou execute`);
                    }
                } catch (error) {
                    console.error(`‚ùå Erreur ${file}:`, error.message);
                }
            }

            console.log(`‚úÖ ${this.commands.size} commandes charg√©es`);
        } catch (error) {
            console.error('‚ùå Erreur chargement commandes:', error);
        }
    }

    async setupEventHandlers() {
        this.client.once('ready', async () => {
            console.log(`‚úÖ ${this.client.user.tag} connect√©`);
            console.log(`üè∞ ${this.client.guilds.cache.size} serveur(s)`);
            console.log(`üìã Commandes disponibles: ${this.commands.size}`);
            
            this.commands.forEach(command => {
                console.log(`  - ${command.data.name}`);
            });

            await this.deployCommands();
        });

        this.client.on('interactionCreate', async interaction => {
            await this.handleInteraction(interaction);
        });

        this.client.on('messageCreate', async message => {
            if (message.author.bot) return;
            
            try {
                const countingHandled = await this.handleCounting(message);
                
                if (!countingHandled) {
                    await this.handleMessageReward(message);
                }
                
                await this.handleAutoThread(message);
                
            } catch (error) {
                console.error('‚ùå Erreur messageCreate:', error);
            }
        });

        this.client.on('error', error => {
            console.error('‚ùå Erreur Discord:', error);
        });
    }

    async deployCommands() {
        try {
            for (const guild of this.client.guilds.cache.values()) {
                console.log(`üéØ Serveur: ${guild.name} (${guild.id})`);
                console.log(`üîÑ Enregistrement serveur sp√©cifique: ${guild.id}...`);
                
                const commands = Array.from(this.commands.values()).map(command => command.data.toJSON());
                console.log(`üìù Pr√©paration de ${commands.length} commandes pour enregistrement`);
                
                commands.forEach(cmd => {
                    console.log(`   ‚Ä¢ ${cmd.name} (${cmd.description})`);
                });

                const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);
                
                await rest.put(
                    Routes.applicationGuildCommands(process.env.CLIENT_ID, guild.id),
                    { body: commands }
                );
                
                console.log(`‚úÖ ${commands.length} commandes enregistr√©es sur serveur ${guild.id}`);
            }
        } catch (error) {
            console.error('‚ùå Erreur d√©ploiement commandes:', error);
        }
    }

    async handleInteraction(interaction) {
        try {
            const MainRouterHandler = require('./handlers/MainRouterHandler');
            const dataManager = require('./utils/simpleDataManager');
            const router = new MainRouterHandler(dataManager);

            if (interaction.isChatInputCommand()) {
                const command = this.commands.get(interaction.commandName);
                if (!command) {
                    console.error(`‚ùå Commande non trouv√©e: ${interaction.commandName}`);
                    return;
                }

                console.log(`üîß /${interaction.commandName} par ${interaction.user.tag}`);
                await command.execute(interaction, dataManager);
            } 
            else if (interaction.isStringSelectMenu() || interaction.isUserSelectMenu() || interaction.isChannelSelectMenu() || interaction.isButton() || interaction.isModalSubmit()) {
                const customId = interaction.customId;
                console.log(`üîÑ MainRouter traite: ${customId}`);
                
                // Routage sp√©cial pour les remises karma
                if (customId === 'karma_discounts_menu' ||
                    customId === 'karma_discounts_actions' ||
                    customId.startsWith('create_karma_discount_modal') || 
                    customId.startsWith('edit_karma_discount_modal') || 
                    customId.startsWith('modify_karma_discount_') || 
                    customId.startsWith('delete_karma_discount_')) {
                    
                    console.log('üéØ Routage remises karma:', customId);
                    const economyHandler = router.handlers.economy;
                    
                    if (customId === 'karma_discounts_menu') {
                        console.log('üîç Appel showKarmaDiscountsConfig...');
                        try {
                            await economyHandler.showKarmaDiscountsConfig(interaction);
                            console.log('‚úÖ showKarmaDiscountsConfig ex√©cut√© avec succ√®s');
                        } catch (error) {
                            console.error('‚ùå Erreur showKarmaDiscountsConfig:', error);
                            await interaction.reply({ content: '‚ùå Erreur lors de l\'affichage des remises karma', flags: 64 });
                        }
                    } else if (customId === 'karma_discounts_actions') {
                        console.log('üîç Traitement actions remises karma');
                        await economyHandler.handleKarmaDiscountsAction(interaction);
                    } else if (customId.startsWith('create_karma_discount_modal')) {
                        await economyHandler.handleCreateKarmaDiscountModal(interaction);
                    } else if (customId.startsWith('edit_karma_discount_modal')) {
                        await economyHandler.handleEditKarmaDiscountModal(interaction);
                    } else if (customId.startsWith('modify_karma_discount_')) {
                        await economyHandler.handleModifyKarmaDiscountSelect(interaction);
                    } else if (customId.startsWith('delete_karma_discount_')) {
                        await economyHandler.handleDeleteKarmaDiscountSelect(interaction);
                    }
                    return;
                }

                // Routage pour achats boutique avec remises automatiques
                if (customId === 'shop_purchase') {
                    console.log('üéØ Routage achat boutique avec remises karma: shop_purchase');
                    await handleShopPurchase(interaction, dataManager);
                    return;
                }

                // Routage pour la commande /objet
                if (customId === 'object_selection' || 
                    customId === 'object_action_menu' ||
                    customId.startsWith('object_offer_') ||
                    customId.startsWith('object_delete_') ||
                    customId.startsWith('object_custom_') ||
                    customId.startsWith('offer_user_select_') ||
                    customId.startsWith('custom_user_select_') ||
                    customId.startsWith('custom_message_modal_') ||
                    customId.startsWith('confirm_delete_') ||
                    customId === 'cancel_delete') {
                    
                    console.log('üéØ Routage objet:', customId);
                    await handleObjectInteraction(interaction, dataManager);
                    return;
                }

                // Routage sp√©cial pour les s√©lecteurs de canal comptage
                if (interaction.isChannelSelectMenu() && customId === 'counting_add_channel') {
                    console.log('üéØ Routage s√©lection canal comptage:', customId);
                    const countingHandler = router.handlers.counting;
                    await countingHandler.handleAddChannel(interaction);
                    return;
                }

                // Routage via MainRouter pour le reste
                const handled = await router.handleInteraction(interaction);
                
                if (!handled && !interaction.replied && !interaction.deferred) {
                    await interaction.reply({ 
                        content: '‚ùå Cette interaction n\'est pas encore impl√©ment√©e.', 
                        flags: 64 
                    });
                }
            }

        } catch (error) {
            console.error('‚ùå Erreur interaction:', error);
            if (!interaction.replied && !interaction.deferred) {
                try {
                    await interaction.reply({
                        content: '‚ùå Erreur lors du traitement de l\'interaction.',
                        flags: 64
                    });
                } catch (replyError) {
                    console.error('‚ùå Erreur envoi r√©ponse:', replyError);
                }
            }
        }
    }

    async handleMessageReward(message) {
        try {
            const dataManager = require('./utils/simpleDataManager');
            const messageRewards = dataManager.getData('message_rewards.json');
            const cooldowns = dataManager.getData('message_cooldowns.json');
            
            const guildConfig = messageRewards[message.guild.id];
            if (!guildConfig || !guildConfig.enabled) return;
            
            const userId = message.author.id;
            const guildId = message.guild.id;
            const cooldownKey = `${userId}_${guildId}`;
            const now = Date.now();
            
            if (cooldowns[cooldownKey] && (now - cooldowns[cooldownKey]) < (guildConfig.cooldown * 1000)) {
                return;
            }
            
            cooldowns[cooldownKey] = now;
            dataManager.setData('message_cooldowns.json', cooldowns);
            
            const user = await dataManager.getUser(userId, guildId);
            user.balance = (user.balance || 1000) + guildConfig.amount;
            user.messageCount = (user.messageCount || 0) + 1;
            
            await dataManager.updateUser(userId, guildId, user);
            
            console.log(`üí∞ ${message.author.tag} a gagn√© ${guildConfig.amount}‚Ç¨ en envoyant un message`);
            
        } catch (error) {
            console.error('‚ùå Erreur r√©compense message:', error);
        }
    }

    async handleAutoThread(message) {
        try {
            const dataManager = require('./utils/simpleDataManager');
            const config = await dataManager.loadData('autothread.json', {});
            const guildId = message.guild.id;
            const channelId = message.channel.id;
            
            const autoThreadConfig = config[guildId];
            if (!autoThreadConfig || !autoThreadConfig.enabled) return;
            
            const isChannelConfigured = autoThreadConfig.channels?.some(c => 
                (typeof c === 'string' ? c : c.channelId) === channelId
            );
            if (!isChannelConfigured) return;
            
            if (message.channel.isThread() || message.channel.type !== 0) return;
            
            let threadName = autoThreadConfig.threadName || 'Discussion - {user}';
            threadName = threadName
                .replace('{user}', message.author.displayName || message.author.username)
                .replace('{channel}', message.channel.name)
                .replace('{date}', new Date().toLocaleDateString('fr-FR'))
                .replace('{time}', new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }));
            
            threadName = threadName.substring(0, 100);
            
            const thread = await message.startThread({
                name: threadName,
                autoArchiveDuration: parseInt(autoThreadConfig.archiveTime) || 60,
                reason: `Auto-thread cr√©√© par ${message.author.tag}`
            });
            
            if (autoThreadConfig.slowMode && autoThreadConfig.slowMode > 0) {
                await thread.setRateLimitPerUser(parseInt(autoThreadConfig.slowMode));
            }
            
            if (!config[guildId].stats) {
                config[guildId].stats = { threadsCreated: 0, lastCreated: null };
            }
            config[guildId].stats.threadsCreated += 1;
            config[guildId].stats.lastCreated = new Date().toISOString();
            
            await dataManager.saveData('autothread.json', config);
            
            console.log(`üßµ Thread cr√©√©: "${threadName}" dans #${message.channel.name} par ${message.author.tag}`);
            
        } catch (error) {
            console.error('‚ùå Erreur cr√©ation auto-thread:', error);
        }
    }

    async handleCounting(message) {
        try {
            // Utiliser le CountingManager complet au lieu de la logique simplifi√©e
            const CountingManager = require('./utils/countingManager');
            
            const guildConfig = CountingManager.getCountingConfig(message.guild.id);
            if (!guildConfig || !guildConfig.channels || guildConfig.channels.length === 0) {
                return false;
            }
            
            const channelConfig = guildConfig.channels.find(c => c.channelId === message.channel.id);
            if (!channelConfig || !channelConfig.enabled) {
                return false;
            }
            
            // Utiliser la validation compl√®te du CountingManager
            const validationResult = await CountingManager.validateCountingMessage(message);
            
            if (validationResult.valid) {
                // Message valide - trait√© par CountingManager
                console.log(`üî¢ ${message.author.tag} a compt√©: ${validationResult.number} (prochain: ${validationResult.number + 1})`);
                return true;
            } else {
                // Message invalide - trait√© par CountingManager (erreurs, reset, etc.)
                return true; // Toujours retourner true car c'est un canal de comptage actif
            }
            
        } catch (error) {
            console.error('‚ùå Erreur handleCounting:', error);
            return false;
        }
    }

    async handleMessageReward(message) {
        try {
            const dataManager = require('./utils/simpleDataManager');
            const economyConfig = await dataManager.loadData('economy.json', {});
            const guildId = message.guild.id;
            
            const guildConfig = economyConfig[guildId]?.messageRewards;
            if (!guildConfig || !guildConfig.enabled) return;
            
            const userId = message.author.id;
            const cooldownKey = `${userId}_${guildId}`;
            const now = Date.now();
            
            if (cooldowns[cooldownKey] && (now - cooldowns[cooldownKey]) < (guildConfig.cooldown * 1000)) {
                return;
            }
            
            cooldowns[cooldownKey] = now;
            dataManager.setData('message_cooldowns.json', cooldowns);
            
            const user = await dataManager.getUser(userId, guildId);
            user.balance = (user.balance || 1000) + guildConfig.amount;
            user.messageCount = (user.messageCount || 0) + 1;
            
            await dataManager.updateUser(userId, guildId, user);
            
            console.log(`üí∞ ${message.author.tag} a gagn√© ${guildConfig.amount}‚Ç¨ en envoyant un message`);
            
        } catch (error) {
            console.error('‚ùå Erreur r√©compense message:', error);
        }
    }

    async handleAutoThread(message) {
        try {
            const dataManager = require('./utils/simpleDataManager');
            const config = await dataManager.loadData('autothread.json', {});
            const guildId = message.guild.id;
            const channelId = message.channel.id;
            
            const autoThreadConfig = config[guildId];
            if (!autoThreadConfig || !autoThreadConfig.enabled) return;
            
            const isChannelConfigured = autoThreadConfig.channels?.some(c => 
                (typeof c === 'string' ? c : c.channelId) === channelId
            );
            if (!isChannelConfigured) return;
            
            if (message.channel.isThread() || message.channel.type !== 0) return;
            
            let threadName = autoThreadConfig.threadName || 'Discussion - {user}';
            threadName = threadName
                .replace('{user}', message.author.displayName || message.author.username)
                .replace('{channel}', message.channel.name)
                .replace('{date}', new Date().toLocaleDateString('fr-FR'))
                .replace('{time}', new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }));
            
            threadName = threadName.substring(0, 100);
            
            const thread = await message.startThread({
                name: threadName,
                autoArchiveDuration: parseInt(autoThreadConfig.archiveTime) || 60,
                reason: `Auto-thread cr√©√© par ${message.author.tag}`
            });
            
            if (autoThreadConfig.slowMode && autoThreadConfig.slowMode > 0) {
                await thread.setRateLimitPerUser(parseInt(autoThreadConfig.slowMode));
            }
            
            if (!config[guildId].stats) {
                config[guildId].stats = { threadsCreated: 0, lastCreated: null };
            }
            config[guildId].stats.threadsCreated += 1;
            config[guildId].stats.lastCreated = new Date().toISOString();
            
            await dataManager.saveData('autothread.json', config);
            
            console.log(`üßµ Thread cr√©√©: "${threadName}" dans #${message.channel.name} par ${message.author.tag}`);
            
        } catch (error) {
            console.error('‚ùå Erreur cr√©ation auto-thread:', error);
        }
    }
}

// Variables globales pour les cooldowns des messages
const cooldowns = {};

// Fonction pour g√©rer les achats avec remises karma automatiques
async function handleShopPurchase(interaction, dataManager) {
                if (channelIndex >= 0) {
                    guildConfig.channels[channelIndex] = channelConfig;
                }
                
                countingConfig[message.guild.id] = guildConfig;
                await fs.writeFile(
                    path.join(__dirname, 'data', 'counting.json'), 
                    JSON.stringify(countingConfig, null, 2)
                );
                
                const { EmbedBuilder } = require('discord.js');
                const resetEmbed = new EmbedBuilder()
                    .setColor('#FF0000')
                    .setTitle('‚ùå Mauvais Nombre !')
                    .setDescription(`**Erreur :** Vous avez √©crit **${numberValue}** mais le nombre attendu √©tait **${expectedNumber}**\n\nüîÑ Le comptage red√©marre √† **1**`)
                    .addFields([
                        { name: 'üìä Nombre atteint', value: previousNumber.toString(), inline: true },
                        { name: 'üèÜ Record actuel', value: (channelConfig.record || 0).toString(), inline: true }
                    ])
                    .setFooter({ text: `Erreur de ${message.author.displayName}` });
                
                await message.channel.send({ embeds: [resetEmbed] });
                
                console.log(`üîÑ Comptage reset: Erreur: attendu ${expectedNumber}, re√ßu ${numberValue} (Record: ${channelConfig.record})`);
                
            } else {
                const isNewRecord = numberValue > (channelConfig.record || 0);
                
                channelConfig.currentNumber++;
                channelConfig.lastUserId = message.author.id;
                channelConfig.totalCounts = (channelConfig.totalCounts || 0) + 1;
                
                const channelIndex = guildConfig.channels.findIndex(c => c.channelId === message.channel.id);
                if (channelIndex >= 0) {
                    guildConfig.channels[channelIndex] = channelConfig;
                }
                
                countingConfig[message.guild.id] = guildConfig;
                await fs.writeFile(
                    path.join(__dirname, 'data', 'counting.json'), 
                    JSON.stringify(countingConfig, null, 2)
                );
                
                try {
                    if (isNewRecord) {
                        await message.react('üèÜ');
                        await message.react('üéâ');
                    } else {
                        await message.react('‚úÖ');
                    }
                } catch (error) {
                    console.error('Impossible d\'ajouter la r√©action:', error);
                }
                
                const milestones = [10, 25, 50, 100, 250, 500, 1000];
                const currentCount = numberValue;
                
                if (milestones.includes(currentCount)) {
                    try {
                        await message.react('üéØ');
                    } catch (error) {
                        console.error('Impossible d\'ajouter la r√©action palier:', error);
                    }
                    
                    const milestoneEmbed = new EmbedBuilder()
                        .setColor('#00FF00')
                        .setTitle('üéâ Palier Atteint!')
                        .setDescription(`F√©licitations ! Vous avez atteint le nombre **${currentCount}** !`)
                        .addFields([
                            { name: 'üë§ Compteur', value: message.author.displayName, inline: true },
                            { name: 'üéØ Prochain nombre', value: channelConfig.currentNumber.toString(), inline: true }
                        ])
                        .setFooter({ text: `Total de comptages: ${channelConfig.totalCounts}` });
                    
                    await message.channel.send({ embeds: [milestoneEmbed] });
                }
                
                console.log(`üî¢ ${message.author.tag} a compt√©: ${numberValue} (prochain: ${channelConfig.currentNumber})`);
            }
            
            return true;
            
        } catch (error) {
            console.error('‚ùå Erreur syst√®me comptage:', error);
            return false;
        }
    }
}

// Fonction pour g√©rer les achats avec remises karma automatiques
async function handleShopPurchase(interaction, dataManager) {
    try {
        const guildId = interaction.guild.id;
        const userId = interaction.user.id;
        const itemId = interaction.values[0];

        // Charger les donn√©es
        const userData = await dataManager.getUser(userId, guildId);
        const shopData = await dataManager.loadData('shop.json', {});
        const economyConfig = await dataManager.loadData('economy.json', {});
        const shopItems = shopData[guildId] || [];

        // Trouver l'objet s√©lectionn√©
        const item = shopItems.find(i => (i.id || shopItems.indexOf(i)).toString() === itemId);
        if (!item) {
            return await interaction.reply({
                content: '‚ùå Objet introuvable dans la boutique.',
                flags: 64
            });
        }

        // Calculer le karma net et la remise (karma net = good + bad, car bad est d√©j√† n√©gatif)
        const userKarmaNet = (userData.goodKarma || 0) + (userData.badKarma || 0);
        let discountPercent = 0;
        
        console.log(`üéØ Karma utilisateur ${interaction.user.tag}: Good=${userData.goodKarma}, Bad=${userData.badKarma}, Net=${userKarmaNet}`);
        
        if (economyConfig.karmaDiscounts?.enabled && economyConfig.karmaDiscounts?.ranges) {
            console.log(`üìä Remises karma activ√©es, ${economyConfig.karmaDiscounts.ranges.length} tranches configur√©es`);
            
            const applicableRanges = economyConfig.karmaDiscounts.ranges.filter(range => userKarmaNet >= range.minKarma);
            console.log(`üîç Tranches applicables pour karma ${userKarmaNet}:`, applicableRanges.map(r => `${r.name} (‚â•${r.minKarma}, ${r.discount}%)`));
            
            const bestRange = applicableRanges.sort((a, b) => b.minKarma - a.minKarma)[0];
            discountPercent = bestRange ? bestRange.discount : 0;
            
            if (bestRange) {
                console.log(`‚úÖ Remise appliqu√©e: ${bestRange.name} (${discountPercent}%)`);
            } else {
                console.log(`‚ùå Aucune remise applicable`);
            }
        } else {
            console.log(`‚ö†Ô∏è Remises karma d√©sactiv√©es ou non configur√©es`);
        }

        // Calculer le prix final avec remise
        const originalPrice = item.price;
        const finalPrice = discountPercent > 0 ? 
            Math.floor(originalPrice * (100 - discountPercent) / 100) : originalPrice;

        // V√©rifier si l'utilisateur a assez d'argent
        if (userData.balance < finalPrice) {
            const missingAmount = finalPrice - userData.balance;
            return await interaction.reply({
                content: `‚ùå **Solde insuffisant !**\n\nüí∞ Prix: ${finalPrice}‚Ç¨ ${discountPercent > 0 ? `(remise ${discountPercent}% appliqu√©e)` : ''}\nüí≥ Votre solde: ${userData.balance}‚Ç¨\n‚ùå Manque: ${missingAmount}‚Ç¨`,
                flags: 64
            });
        }

        // Effectuer l'achat
        userData.balance -= finalPrice;
        
        // Ajouter seulement les objets personnalis√©s √† l'inventaire
        if (item.type === 'custom') {
            if (!userData.inventory) userData.inventory = [];
            userData.inventory.push({
                id: item.id,
                name: item.name,
                description: item.description,
                type: item.type,
                price: originalPrice,
                purchasedAt: new Date().toISOString()
            });
        }
        
        await dataManager.updateUser(userId, guildId, userData);

        // Appliquer l'effet de l'objet selon son type
        let effectMessage = '';
        if (item.type === 'temporary_role' && item.roleId) {
            try {
                const role = await interaction.guild.roles.fetch(item.roleId);
                if (role) {
                    await interaction.member.roles.add(role);
                    effectMessage = `\nüé≠ R√¥le **${role.name}** ajout√© pour ${item.duration} jour(s) !`;
                    
                    // Programmer la suppression du r√¥le apr√®s la dur√©e
                    setTimeout(async () => {
                        try {
                            await interaction.member.roles.remove(role);
                        } catch (error) {
                            console.error('‚ùå Erreur suppression r√¥le temporaire:', error);
                        }
                    }, item.duration * 24 * 60 * 60 * 1000);
                }
            } catch (error) {
                effectMessage = '\n‚ö†Ô∏è Erreur lors de l\'attribution du r√¥le.';
            }
        } else if (item.type === 'permanent_role' && item.roleId) {
            try {
                const role = await interaction.guild.roles.fetch(item.roleId);
                if (role) {
                    await interaction.member.roles.add(role);
                    effectMessage = `\nüé≠ R√¥le permanent **${role.name}** ajout√© !`;
                }
            } catch (error) {
                effectMessage = '\n‚ö†Ô∏è Erreur lors de l\'attribution du r√¥le.';
            }
        } else if (item.type === 'custom') {
            effectMessage = '\nüéÅ Objet personnalis√© achet√© !';
        } else {
            effectMessage = '\nüì¶ Objet ajout√© √† votre inventaire !';
        }

        // Message de confirmation avec d√©tails de la remise
        let confirmMessage = `‚úÖ **Achat r√©ussi !**\n\nüõí **${item.name}**\nüí∞ Prix pay√©: **${finalPrice}‚Ç¨**`;
        
        if (discountPercent > 0) {
            const savedAmount = originalPrice - finalPrice;
            confirmMessage += `\nüí∏ Prix original: ~~${originalPrice}‚Ç¨~~\nüéØ Remise karma (${discountPercent}%): **-${savedAmount}‚Ç¨**\n‚öñÔ∏è Votre karma net: ${userKarmaNet}`;
        }
        
        confirmMessage += `\nüí≥ Nouveau solde: **${userData.balance}‚Ç¨**${effectMessage}`;

        await interaction.reply({
            content: confirmMessage,
            flags: 64
        });

        // Log de l'achat
        console.log(`üõí ${interaction.user.tag} a achet√© "${item.name}" pour ${finalPrice}‚Ç¨ ${discountPercent > 0 ? `(remise ${discountPercent}%)` : ''}`);

    } catch (error) {
        console.error('‚ùå Erreur achat boutique:', error);
        await interaction.reply({
            content: '‚ùå Une erreur est survenue lors de l\'achat.',
            flags: 64
        });
    }
}

async function handleObjectInteraction(interaction, dataManager) {
        const customId = interaction.customId;
        const userId = interaction.user.id;
        const guildId = interaction.guild.id;
        
        try {
            const economyData = await dataManager.loadData('economy.json', {});
            const userKey = `${userId}_${guildId}`;
            const userData = economyData[userKey] || { inventory: [] };
            
            // Filtrer les objets personnalis√©s uniquement
            const customObjects = userData.inventory ? userData.inventory.filter(item => item.type === 'custom') : [];
            
            if (customId === 'object_selection') {
                const objectIndex = parseInt(interaction.values[0].replace('object_', ''));
                const selectedObject = customObjects[objectIndex];
                
                if (!selectedObject) {
                    return await interaction.update({
                        content: '‚ùå Objet introuvable dans votre inventaire.',
                        components: []
                    });
                }
                
                const { EmbedBuilder, StringSelectMenuBuilder, ActionRowBuilder } = require('discord.js');
                
                const embed = new EmbedBuilder()
                    .setColor('#9b59b6')
                    .setTitle(`üéØ ${selectedObject.name}`)
                    .setDescription(selectedObject.description || 'Objet de boutique')
                    .addFields([
                        {
                            name: 'üì¶ Type',
                            value: getItemTypeLabel(selectedObject.type),
                            inline: true
                        },
                        {
                            name: 'üí∞ Prix d\'Achat',
                            value: `${selectedObject.price || 'N/A'}‚Ç¨`,
                            inline: true
                        },
                        {
                            name: '‚ö° Choisissez une Action',
                            value: 'üéÅ **Offrir** - Donner √† un membre\nüóëÔ∏è **Supprimer** - Retirer de l\'inventaire\nüí¨ **Interaction** - Message personnalis√©',
                            inline: false
                        }
                    ]);
                
                const actionMenu = new StringSelectMenuBuilder()
                    .setCustomId('object_action_menu')
                    .setPlaceholder('Que voulez-vous faire ?')
                    .addOptions([
                        {
                            label: 'üéÅ Offrir',
                            value: `object_offer_${objectIndex}`,
                            description: 'Donner cet objet √† un membre du serveur',
                            emoji: 'üéÅ'
                        },
                        {
                            label: 'üóëÔ∏è Supprimer',
                            value: `object_delete_${objectIndex}`,
                            description: 'Retirer cet objet de votre inventaire',
                            emoji: 'üóëÔ∏è'
                        },
                        {
                            label: 'üí¨ Interaction Personnalis√©e',
                            value: `object_custom_${objectIndex}`,
                            description: 'Utiliser avec message personnalis√©',
                            emoji: 'üí¨'
                        }
                    ]);
                
                const row = new ActionRowBuilder().addComponents(actionMenu);
                await interaction.update({ embeds: [embed], components: [row] });
                
            } else if (customId === 'object_action_menu') {
                const actionValue = interaction.values[0];
                
                if (actionValue.startsWith('object_offer_')) {
                    await handleObjectOffer(interaction, dataManager, actionValue);
                } else if (actionValue.startsWith('object_delete_')) {
                    await handleObjectDelete(interaction, dataManager, actionValue);
                } else if (actionValue.startsWith('object_custom_')) {
                    await handleObjectCustom(interaction, dataManager, actionValue);
                } else if (actionValue === 'received') {
                    await handleReceivedObjects(interaction, dataManager);
                }
            } else if (customId.startsWith('custom_user_select_')) {
                console.log('üéØ Handler custom_user_select appel√©');
                await handleCustomUserSelect(interaction, dataManager);
            } else if (customId.startsWith('custom_message_modal_')) {
                console.log('üéØ Handler custom_message_modal appel√©');
                await handleCustomMessageModal(interaction, dataManager);
            } else if (customId.startsWith('offer_user_select_')) {
                await handleOfferUserSelect(interaction, dataManager);
            } else if (customId.startsWith('confirm_delete_')) {
                await handleConfirmDelete(interaction, dataManager);
            } else if (customId === 'cancel_delete') {
                await interaction.update({
                    content: '‚ùå Suppression annul√©e.',
                    components: []
                });
            }
            
        } catch (error) {
            console.error('‚ùå Erreur handleObjectInteraction:', error);
            await interaction.reply({
                content: '‚ùå Erreur lors de la gestion des objets.',
                flags: 64
            });
        }
    }

// Fonction pour g√©rer l'affichage des objets re√ßus
async function handleReceivedObjects(interaction, dataManager) {
    try {
        const userId = interaction.user.id;
        const guildId = interaction.guild.id;
        
        // Charger les objets re√ßus
        const giftedData = await dataManager.loadData('gifted_objects.json', {});
        const userGiftedKey = `${userId}_${guildId}`;
        const receivedObjects = giftedData[userGiftedKey] || [];
        
        const { EmbedBuilder, StringSelectMenuBuilder, ActionRowBuilder } = require('discord.js');
        
        if (receivedObjects.length === 0) {
            const embed = new EmbedBuilder()
                .setColor('#e74c3c')
                .setTitle('üéÅ Aucun Objet Re√ßu')
                .setDescription('Vous n\'avez re√ßu aucun objet pour le moment.\n\nDemandez √† quelqu\'un de vous offrir un objet avec `/objet` !');
                
            return await interaction.update({ embeds: [embed], components: [] });
        }
        
        const embed = new EmbedBuilder()
            .setColor('#f39c12')
            .setTitle('üéÅ Objets Re√ßus')
            .setDescription('Voici les objets que vous avez re√ßus d\'autres membres')
            .addFields([
                {
                    name: 'üì¶ Vos Objets Re√ßus',
                    value: receivedObjects.map((item, index) => {
                        const giftDate = new Date(item.receivedAt).toLocaleDateString('fr-FR');
                        return `üé® **${item.name}** - Offert par <@${item.giftedBy}> le ${giftDate}`;
                    }).join('\n'),
                    inline: false
                },
                {
                    name: '‚ö° Actions Disponibles',
                    value: 'üí¨ **Interaction** - Utiliser l\'objet avec message personnalis√©\nüóëÔ∏è **Supprimer** - Retirer l\'objet de votre inventaire',
                    inline: false
                }
            ]);
        
        if (receivedObjects.length <= 25) {
            const selectMenu = new StringSelectMenuBuilder()
                .setCustomId('received_object_selection')
                .setPlaceholder('Choisissez un objet re√ßu...')
                .addOptions(
                    receivedObjects.map((item, index) => ({
                        label: item.name,
                        value: `received_${index}`,
                        description: `Offert par ${item.giftedByName || 'un membre'}`,
                        emoji: 'üéÅ'
                    }))
                );
            
            const row = new ActionRowBuilder().addComponents(selectMenu);
            await interaction.update({ embeds: [embed], components: [row] });
        } else {
            await interaction.update({ embeds: [embed], components: [] });
        }
        
    } catch (error) {
        console.error('‚ùå Erreur handleReceivedObjects:', error);
        await interaction.update({
            content: '‚ùå Erreur lors de l\'affichage des objets re√ßus.',
            components: []
        });
    }
}

async function handleObjectOffer(interaction, dataManager, actionValue) {
    const { UserSelectMenuBuilder, ActionRowBuilder, EmbedBuilder } = require('discord.js');
    const objectIndex = parseInt(actionValue.replace('object_offer_', ''));
    
    const embed = new EmbedBuilder()
        .setColor('#f39c12')
        .setTitle('üéÅ Offrir un Objet')
        .setDescription('S√©lectionnez le membre √† qui offrir cet objet');
    
    const userSelect = new UserSelectMenuBuilder()
        .setCustomId(`offer_user_select_${objectIndex}`)
        .setPlaceholder('Choisir un membre...')
        .setMaxValues(1);
    
    const row = new ActionRowBuilder().addComponents(userSelect);
    await interaction.update({ embeds: [embed], components: [row] });
}

async function handleObjectDelete(interaction, dataManager, actionValue) {
    const { EmbedBuilder, ButtonBuilder, ButtonStyle, ActionRowBuilder } = require('discord.js');
    const objectIndex = parseInt(actionValue.replace('object_delete_', ''));
    
    const userId = interaction.user.id;
    const guildId = interaction.guild.id;
    const economyData = await dataManager.loadData('economy.json', {});
    const userKey = `${userId}_${guildId}`;
    const userData = economyData[userKey] || { inventory: [] };
    const objectToDelete = userData.inventory[objectIndex];
    
    if (!objectToDelete) {
        return await interaction.update({
            content: '‚ùå Objet introuvable.',
            components: []
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor('#e74c3c')
        .setTitle('üóëÔ∏è Confirmation de Suppression')
        .setDescription(`√ätes-vous s√ªr de vouloir supprimer **${objectToDelete.name}** de votre inventaire ?\n\n‚ö†Ô∏è Cette action est irr√©versible !`);
    
    const confirmButton = new ButtonBuilder()
        .setCustomId(`confirm_delete_${objectIndex}`)
        .setLabel('‚úÖ Confirmer')
        .setStyle(ButtonStyle.Danger);
    
    const cancelButton = new ButtonBuilder()
        .setCustomId('cancel_delete')
        .setLabel('‚ùå Annuler')
        .setStyle(ButtonStyle.Secondary);
    
    const row = new ActionRowBuilder().addComponents(confirmButton, cancelButton);
    await interaction.update({ embeds: [embed], components: [row] });
}

async function handleObjectCustom(interaction, dataManager, actionValue) {
    const { UserSelectMenuBuilder, ActionRowBuilder, EmbedBuilder } = require('discord.js');
    const objectIndex = parseInt(actionValue.replace('object_custom_', ''));
    
    const userId = interaction.user.id;
    const guildId = interaction.guild.id;
    const economyData = await dataManager.loadData('economy.json', {});
    const userKey = `${userId}_${guildId}`;
    const userData = economyData[userKey] || { inventory: [] };
    const customObjects = userData.inventory ? userData.inventory.filter(item => item.type === 'custom') : [];
    const selectedObject = customObjects[objectIndex];
    
    if (!selectedObject) {
        return await interaction.update({
            content: '‚ùå Objet introuvable.',
            components: []
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor('#9b59b6')
        .setTitle('üí¨ Interaction Personnalis√©e')
        .setDescription(`üéØ **Objet:** ${selectedObject.name}\n\n**√âtape 1/2:** S√©lectionnez le membre √† cibler avec votre objet`);
    
    const userSelect = new UserSelectMenuBuilder()
        .setCustomId(`custom_user_select_${objectIndex}`)
        .setPlaceholder('Choisir un membre...')
        .setMaxValues(1);
    
    const row = new ActionRowBuilder().addComponents(userSelect);
    await interaction.update({ embeds: [embed], components: [row] });
}

async function handleCustomUserSelect(interaction, dataManager) {
    try {
        console.log(`üéØ R√©ception interaction UserSelect: ${interaction.customId}`);
        console.log(`üéØ Type d'interaction: ${interaction.constructor.name}`);
        console.log(`üéØ Valeurs s√©lectionn√©es: ${interaction.values}`);
        
        const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = require('discord.js');
        const objectIndex = parseInt(interaction.customId.replace('custom_user_select_', ''));
        const selectedUserId = interaction.values[0];
        
        console.log(`üéØ S√©lection utilisateur: objectIndex=${objectIndex}, userId=${selectedUserId}`);
        
        const modal = new ModalBuilder()
            .setCustomId(`custom_message_modal_${objectIndex}_${selectedUserId}`)
            .setTitle('üí¨ Interaction Personnalis√©e');
        
        const messageInput = new TextInputBuilder()
            .setCustomId('custom_message')
            .setLabel('√âtape 2/2: Votre message')
            .setStyle(TextInputStyle.Paragraph)
            .setMinLength(1)
            .setMaxLength(500)
            .setPlaceholder('Tapez votre message personnalis√© ici...')
            .setRequired(true);
        
        const messageRow = new ActionRowBuilder().addComponents(messageInput);
        modal.addComponents(messageRow);
        
        await interaction.showModal(modal);
        console.log('‚úÖ Modal affich√© avec succ√®s');
        
    } catch (error) {
        console.error('‚ùå Erreur handleCustomUserSelect:', error);
        if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({
                content: '‚ùå Erreur lors de l\'affichage du modal.',
                flags: 64
            });
        }
    }
}

async function handleCustomMessageModal(interaction, dataManager) {
    const { EmbedBuilder } = require('discord.js');
    const customMessage = interaction.fields.getTextInputValue('custom_message');
    
    // Extraire l'index de l'objet et l'ID du membre depuis le customId
    const parts = interaction.customId.replace('custom_message_modal_', '').split('_');
    const objectIndex = parseInt(parts[0]);
    const targetUserId = parts[1];
    
    const userId = interaction.user.id;
    const guildId = interaction.guild.id;
    
    try {
        const economyData = await dataManager.loadData('economy.json', {});
        const userKey = `${userId}_${guildId}`;
        const userData = economyData[userKey] || { inventory: [] };
        const customObjects = userData.inventory ? userData.inventory.filter(item => item.type === 'custom') : [];
        const selectedObject = customObjects[objectIndex];
        
        if (!selectedObject) {
            return await interaction.reply({
                content: '‚ùå Objet introuvable.',
                flags: 64
            });
        }
        
        // R√©cup√©rer le membre cible
        const targetUser = await interaction.guild.members.fetch(targetUserId);
        
        // Envoyer dans le canal actuel avec le format demand√©
        await interaction.reply({
            content: `<@${interaction.user.id}> ${customMessage} avec **${selectedObject.name}** <@${targetUserId}>`
        });
        
        console.log(`üí¨ ${interaction.user.tag} a utilis√© "${selectedObject.name}" sur ${targetUser.user.tag}: ${customMessage}`);
        
    } catch (error) {
        console.error('‚ùå Erreur interaction personnalis√©e:', error);
        await interaction.reply({
            content: '‚ùå Erreur lors de l\'envoi de l\'interaction personnalis√©e.',
            flags: 64
        });
    }
}

async function handleOfferUserSelect(interaction, dataManager) {
    const objectIndex = parseInt(interaction.customId.replace('offer_user_select_', ''));
    const targetUserId = interaction.values[0];
    const userId = interaction.user.id;
    const guildId = interaction.guild.id;
    
    try {
        // R√©cup√©rer l'objet √† offrir
        const economyData = await dataManager.loadData('economy.json', {});
        const userKey = `${userId}_${guildId}`;
        const userData = economyData[userKey] || { inventory: [] };
        const customObjects = userData.inventory ? userData.inventory.filter(item => item.type === 'custom') : [];
        const objectToGift = customObjects[objectIndex];
        
        if (!objectToGift) {
            return await interaction.update({
                content: '‚ùå Objet introuvable dans votre inventaire.',
                components: []
            });
        }
        
        // V√©rifier que l'utilisateur ne s'offre pas l'objet √† lui-m√™me
        if (targetUserId === userId) {
            return await interaction.update({
                content: '‚ùå Vous ne pouvez pas vous offrir un objet √† vous-m√™me !',
                components: []
            });
        }
        
        // R√©cup√©rer le membre cible
        const targetMember = await interaction.guild.members.fetch(targetUserId);
        
        // Retirer l'objet de l'inventaire du donneur (supprime uniquement l'objet sp√©cifique)
        const allUserInventory = userData.inventory || [];
        const objectToRemoveIndex = allUserInventory.findIndex(item => 
            item.type === 'custom' && 
            item.name === objectToGift.name && 
            item.id === objectToGift.id
        );
        
        if (objectToRemoveIndex !== -1) {
            allUserInventory.splice(objectToRemoveIndex, 1);
            userData.inventory = allUserInventory;
            economyData[userKey] = userData;
            await dataManager.saveData('economy.json', economyData);
        }
        
        // Ajouter l'objet aux objets re√ßus du destinataire
        const giftedData = await dataManager.loadData('gifted_objects.json', {});
        const recipientKey = `${targetUserId}_${guildId}`;
        
        if (!giftedData[recipientKey]) {
            giftedData[recipientKey] = [];
        }
        
        // Cr√©er l'objet offert avec m√©tadonn√©es
        const giftedObject = {
            ...objectToGift,
            giftedBy: userId,
            giftedByName: interaction.user.displayName,
            receivedAt: new Date().toISOString(),
            originalOwner: objectToGift.createdBy || userId
        };
        
        giftedData[recipientKey].push(giftedObject);
        await dataManager.saveData('gifted_objects.json', giftedData);
        
        // Confirmation du transfert
        await interaction.update({
            content: `‚úÖ **${objectToGift.name}** a √©t√© offert √† ${targetMember.displayName} avec succ√®s !\n\nüéÅ L'objet a √©t√© retir√© de votre inventaire et ajout√© aux objets re√ßus de ${targetMember.displayName}.`,
            components: []
        });
        
        console.log(`üéÅ ${interaction.user.tag} a offert "${objectToGift.name}" √† ${targetMember.user.tag}`);
        
    } catch (error) {
        console.error('‚ùå Erreur handleOfferUserSelect:', error);
        await interaction.update({
            content: '‚ùå Erreur lors de l\'offre de l\'objet.',
            components: []
        });
    }
}

async function handleConfirmDelete(interaction, dataManager) {
    const objectIndex = parseInt(interaction.customId.replace('confirm_delete_', ''));
    const userId = interaction.user.id;
    const guildId = interaction.guild.id;
    
    try {
        const economyData = await dataManager.loadData('economy.json', {});
        const userKey = `${userId}_${guildId}`;
        const userData = economyData[userKey] || { inventory: [] };
        const customObjects = userData.inventory ? userData.inventory.filter(item => item.type === 'custom') : [];
        
        if (!customObjects[objectIndex]) {
            return await interaction.update({
                content: '‚ùå Objet introuvable.',
                components: []
            });
        }
        
        const deletedObject = customObjects[objectIndex];
        
        // Supprimer l'objet de l'inventaire complet (pas seulement des objets personnalis√©s)
        const originalIndex = userData.inventory.findIndex(item => 
            item.id === deletedObject.id && item.type === 'custom'
        );
        
        if (originalIndex !== -1) {
            userData.inventory.splice(originalIndex, 1);
            await dataManager.updateUser(userId, guildId, userData);
            
            await interaction.update({
                content: `‚úÖ **${deletedObject.name}** a √©t√© supprim√© de votre inventaire.`,
                components: []
            });
            
            console.log(`üóëÔ∏è ${interaction.user.tag} a supprim√© "${deletedObject.name}" de son inventaire`);
        } else {
            await interaction.update({
                content: '‚ùå Erreur lors de la suppression.',
                components: []
            });
        }
        
    } catch (error) {
        console.error('‚ùå Erreur suppression objet:', error);
        await interaction.update({
            content: '‚ùå Erreur lors de la suppression.',
            components: []
        });
    }
}

function getItemTypeLabel(type) {
    switch(type) {
        case 'custom': return 'üé® Objet Personnalis√©';
        case 'temp_role': return '‚åõ R√¥le Temporaire';
        case 'perm_role': return '‚≠ê R√¥le Permanent';
        default: return 'üì¶ Objet Standard';
    }
}

// D√©marrage
console.log('üöÄ BAG BOT V2 - Solution Render.com Finale');
new RenderSolutionBot();